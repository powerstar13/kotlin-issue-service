# 이슈 관리 서비스

## 공통 에러 처리

1. API를 개발할 땐 에러가 발생했을 때의 상황을 고려해 항상 일관된 에러 처리 규칙을 정해야 한다.
2. 에러 응답 모델 정의
    - code로 어떤 에러가 발생했는지 정의한다.
        - HTTP status code만으로 모든 에러에 대한 케이스를 처리하기 어렵다.
    - 에러가 발생했을 때 나타낼 메시지를 표시한다.
        - 메시지에는 stacktrace와 같이 언어, 프레임워크 정보, DB 필드 등이 노출되면 절대 안 된다.
3. Exception 구조 정의
4. GlobalExceptionHandler 정의
    1. `@RestControllerAdvice` 또는 `@ControllerAdvice`를 사용하면 Controller에서 발생하는 모든 예외를 감지할 수 있다.
    2. ExceptionHandler에서 정해진 ErrorResponse 객체로 응답하게 되면 항상 일관성있는 에러 처리를 할 수 있게 된다.

## 이슈 등록

1. 도메인 모델링
   1. 공통 엔티티로 만들 BaseEntity 추가
      1. **모든 엔티티에서 사용할 공통된 속성을 정의하고 싶은 경우, `@MappedSuperclass`를 사용해 부모 엔티티에서 공통 속성을 정의하고 하위 엔티티에서 상속받아 사용할 수 있다.**
      2. `@EntityListeners`: 엔티티에 특정한 이벤트가 발생하면 정해진 콜백 처리를 할 수 있다.
      3. `AuditingEventListener`를 사용하면 엔티티가 생성될 때 `@CreatedDate`가 붙은 프로퍼티에 생성일시를 자동으로 넣어주고, 엔티티에 변경이 일어나면 `@LastModifiedDate`가 붙은 프로퍼티에 변경일시를 자동으로 넣어주게 된다.
   2. `@EnableJpaAuditing`: AuditingEventListener를 사용하려면 `@EnableJpaAuditing` 애노테이션을 MainApplication에 추가해야 한다.
   3. 이슈 관리 서비스의 핵심 엔티티인 이슈 엔티티 생성
2. 리포지토리 생성
3. 서비스 생성
   1. request, response DTO를 생성
4. 컨트롤러 생성
5. API 테스트

## 이슈 목록 조회

1. 컨트롤러 작성
2. 서비스 작성
3. 리포지토리 작성
4. API 테스트

## 이슈 상세 조회

1. 컨트롤러 작성
2. 서비스 작성
3. API 테스트

## 이슈 수정

1. 컨트롤러 작성
2. 서비스 작성
3. API 테스트

## 이슈 삭제

1. 컨트롤러 작성
2. 서비스 작성
3. API 테스트

## 코멘트 등록

1. 도메인 모델링
2. 리포지토리 생성
3. 서비스 생성
4. DTO 생성
   1. 기존 IssueModel은 `operator fun invoke`를 재정의해서 사용했지만, Comment 모델에선 확장함수를 사용해서 toResponse를 정의한다.
   2. 실무에선 이와 같이 다양한 방식을 사용하므로 팀내 컨벤션이 있다면 그 방식을 따르는 것이 좋다.
5. 컨트롤러 생성
6. API 테스트

## 코멘트 수정

1. 컨트롤러 작성
2. 서비스 작성
3. 리포지토리 작성
4. API 테스트

## 코멘트 삭제

1. 컨트롤러 작성
2. 서비스 작성
3. API 테스트

---

# 회원 인증 서비스

## 프로젝트 구성하기

1. user-service 모듈 생성
2. kapt 플러그인 추가
3. WebFlux & Coroutine & R2DBC 의존성 사용
4. schema.sql 작성
5. server port 변경
6. R2DBC Config 작성
7. CORS 처리

## 공통 에러 처리

1. 에러 응답 모델 정의
   - code로 어떤 에러가 발생했는지 정의한다.
      - HTTP status code만으로 모든 에러에 대한 케이스를 처리하기 어렵다.
   - 에러가 발생했을 때 나타낼 메시지를 표시한다.
      - 메시지에는 stacktrace와 같이 언어, 프레임워크 정보, DB 필드 등이 노출되면 절대 안 된다.
2. Exception 구조 정의
   1. 최상위 `ServerException`을 sealed class로 정의
3. GlobalExceptionHandler 정의
   1. 애플리케이션에서 발생하는 모든 예외를 처리하는 GlobalExceptionHandler를 정의한다.
   2. ExceptionHandler에서 정해진 ErrorResponse 객체로 응답하게 되면 항상 일관성있는 에러 처리를 할 수 있게 된다.

## 토큰 기반 인증

1. 사용자의 로그인 상태를 처리하는 방법은 대표적으로 `세션 기반 인증` 방식과 `토큰 기반 인증` 방식으로 나뉜다.
2. 세션 기반 인증 방식은 서버가 클라이언트의 세션 정보를 저장하고 있는 `stateful` 방식이다.
   1. 특징
      1. 사용자가 로그인을 하면 서버는 사용자 정보 검증 후 세션 ID를 발급하고 브라우저 쿠키에 저장한다.
      2. 브라우저는 모든 요청마다 쿠키에 있는 세션 ID를 포함하고, 서버는 세션 ID를 통해 유저 정보를 세션 스토리지에서 조회한다.
      3. 일반적으로 서버 메모리, 데이터베이스 등을 사용해 세션을 저장한다.
      4. 세션은 서버에서 `만료(invalidate)` 시켜서 클라이언트의 권한을 회수할 수 있다.
   2. 단점
      1. 서버 확장이 어렵다.
         1. 분산 환경에서는 세션을 공유할 수 있는 세션 클러스터링이 필요하다.
      2. 중앙에서 세션을 관리할 수 있는 세션 데이터베이스를 구축해야 한다.
      3. 요청이 많아지면 세션 조회에 따른 데이터베이스 부하가 심해질 수 있다.
3. 토큰 기반 인증 방식은 서버가 클라이언트의 세션을 저장하지 않기 때문에 `stateless` 방식이다.
   1. 대표적으로 JWT(JSON Web Token)가 있다.
   2. 특징
      1. 사용자가 로그인을 하면 서버는 사용자 정보 검증 후 토큰을 발급하고 응답으로 내려준다.
      2. 클라이언트는 토큰을 저장하고 있다가 `Authorization`  헤더에 토큰을 전달한다.
      3. **서버가 분산된 환경에서도 서버에선 클러스터링 처리가 필요 없다는 것이 장점이다.**
      4. JWT 토큰 내부에는 기본적인 정보와 검증된 토큰임을 증명하는 서명과 같은 유용한 정보를 가지고 있다.
      5. **토큰 안에 유용한 정보를 담고 있어서 I/O 작업을 하지 않아도 된다.**
   3. 단점
      1. 한 번 발행된 토큰은 클라이언트가 보관하고 있으므로 회수하기 어렵다.
      2. 회수가 어렵고 탈취되면 대처가 어려우므로 만료 시간을 짧게 가져가야 한다.
      3. 토큰이 암호화로 인해 길기 때문에 네트워크 부하가 커질 수 있다.
      4. 페이로드는 암호화된 정보가 아니기 때문에 민감 정보를 담아선 안 된다.
      5. JWT의 경우 단일 키를 사용하기 때문에 시크릿 키가 유출되면 보안 취약 사항이 된다.
4. JWT 토큰 구조
   1. JWT 토큰은 세 가지 구성 요소로 이뤄져 있다.
      - **헤더(Header)**: 토큰 타입과 서명 알고리즘을 정의한다.
      - **페이로드(Payload)**: 토큰 발급자, 토큰 유효기간, 유저 정보 등을 정의한다.
      - **서명(Signature)**: 메시지가 전송 과정에서 바뀌지 않은 것을 확인하는 보안 서명
   2. 세 가지 구성요소는 점(`.`)으로 구분한다.

## JWT 기반 인증 구현

1. build.gradle.kts
   1. `com.auth0:java-jwt`
   2. `at.favre.lib:bcrypt`
2. application.yml
   1. jwt 정보 작성
3. JwtUtil
   1. createToken 작성
   2. decode 작성
4. JwtUtilTest

## 회원 가입

1. 도메인 모델링
2. 리포지토리
3. 서비스
4. BCyptUtil
5. 컨트롤러
6. API 테스트

## 로그인과 로그아웃

1. 컨트롤러 작성
2. 서비스 작성
3. CoroutineCahceManager 생성
4. AuthToken 애노테이션 생성

## 내정보 조회

1. 컨트롤러 작성
2. 서비스 작성

## 리포터 조회

1. 다른 유저가 생성한 이슈를 열었을 때, 작성자의 이름을 가져오기 위한 API
2. 컨트롤러 작성
